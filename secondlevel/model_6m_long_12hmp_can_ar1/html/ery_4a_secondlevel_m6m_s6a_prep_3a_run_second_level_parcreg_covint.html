
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>ery_4a_secondlevel_m6m_s6a_prep_3a_run_second_level_parcreg_covint</title><meta name="generator" content="MATLAB 9.10"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2022-12-09"><meta name="DC.source" content="ery_4a_secondlevel_m6m_s6a_prep_3a_run_second_level_parcreg_covint.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; }

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }
span.typesection { color:#A0522D }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h2>Contents</h2><div><ul><li><a href="#1">prep_3a_run_second_level_regression_and_save_parcelregression_covariates_intensity.m</a></li><li><a href="#2">GET AND SET OPTIONS</a></li><li><a href="#3">CHECK REQUIRED DAT FIELDS</a></li><li><a href="#4">MASKING</a></li><li><a href="#5">RUN SECOND LEVEL REGRESSION FOR EACH CONTRAST</a></li><li><a href="#6">SAVE RESULTS</a></li></ul></div><h2 id="1">prep_3a_run_second_level_regression_and_save_parcelregression_covariates_intensity.m</h2><p>USAGE</p><p>This script 1) runs second&#8315;level (i.e. across subjects) regression analyses   for each within-subject CONTRAST or CONDITION registered in the DAT   structure, either       a) voxel-wise, calling CANlab's regress() function under the hood,       including its robust regression option if specified       b) parcel-wise, calling CANlab's robfit_parcelwise() function under the       hood, which is robust by default 2) saves the results using standard naming and location</p><p>Run this script with Matlab's publish function to generate html report of results: publish('prep_3a_run_second_level_regression_and_save','outputDir',htmlsavedir)</p><p>To get results reports after bootstrapping, publish c2a_second_level_regression</p><p>OPTIONS</p><p>NOTE: defaults are specified in a2_set_default_options for any given model, but if you want to run the same model with different options (for example voxel- and parcelwise regression), you can make a copy of this script with a letter index (e.g. <i>s6a</i>) and change the default option here</p><p>- dorobust : robust regression or OLS (true/false) - dorobfit_parcelwise: voxel- or parcelwise regression (true/false) - % OPTION ADDED BY @LUKASVO76 MAY 2022       - csf_wm_covs: true adds global wm &amp; csf regressors at second level       - remove_outliers: true removes outlier images/subjects based on mahalanobis distance - myscaling_glm: 'raw', 'scaled', or 'scaled_contrasts' (defined in a2_set_..., image scaling done in prep_2_... and prep_3_... data load) - maskname_glm:       - default use of sparse gray matter mask       - model-specific maskdir defined in a_set_up_paths_always_run_first script       - if you do not want to mask, change to []       - if you want to use a custom mask, put it in maskdir and change name here       - only used for visualization of uncorrected results in this script - design_matrix_type: 'group', 'custom', or 'onesample'                       Group: use DAT.BETWEENPERSON.group or DAT.BETWEENPERSON.contrasts{c}.group;                       Custom: use all columns of table object DAT.BETWEENPERSON.contrasts{c};                       Onesample: use constant (i.e. intercept) only</p><pre>     - 'group' option
         Assuming that groups are concatenated in contrast image lists, and
         regressor values of 1 or -1 will specify the group identity for each
         image. Requires DAT.BETWEENPERSON.group field specifying group membership for
         each image.</pre><pre>     - 'custom' option:
         Can enter a multi-column design matrix for each contrast
         Design matrix can be different for each contrast</pre><pre>     - 'onesample' option:
         Only adds intercept, hence performs a one-sample t-test on contrast
         images across all subjects, similarly to c_univariate_contrast_maps_
         scripts, but with more flexible options including scaling and robustfit</pre><pre>     OPTION ADDED BY @LUKASVO76 MAY 2022</pre><pre>     NOTE: To set up group and custom variables, see prep_1b_prep_behavioral_data</pre><p>MANDATORY OPTIONS TO BE SPECIFIED IN THIS SCRIPT</p><p>- mygroupfieldname: 'contrasts' or 'conditions' - results_suffix: name to add to results file to specify in case of multiple versions of model, e.g. 'covariate_rating'</p><pre class="codeinput"><span class="comment">%__________________________________________________________________________</span>
<span class="comment">%</span>
<span class="comment">% revamped by: Lukas Van Oudenhove</span>
<span class="comment">% date:   Dartmouth, May, 2022</span>
<span class="comment">%</span>
<span class="comment">%__________________________________________________________________________</span>
<span class="comment">% @(#)% prep_3a_run_second_level_regression_and_save.m         v3.2</span>
<span class="comment">% last modified: 2022/09/02</span>
</pre><pre class="codeoutput error">Error using save
Unable to write file /data/proj_erythritol/proj_erythritol_4a/secondlevel/model_6m_long_12hmp_can_ar1/results/parcelwise_stats_and_maps_contrasts_no_scaling_covariate_rating.mat: permission denied.

Error in ery_4a_secondlevel_m6m_s6a_prep_3a_run_second_level_parcreg_cov (line 664)
        save(savefilenamedata, 'parcelwise_stats_results', '-v7.3');
</pre><h2 id="2">GET AND SET OPTIONS</h2><p>-------------------------------------------------------------------------</p><pre class="codeinput"><span class="comment">% SET MANDATORY OPTIONS</span>

mygroupnamefield = <span class="string">'contrasts'</span>;
results_suffix = <span class="string">'covintensity_rating'</span>; <span class="comment">% adds a suffix of your choice to .mat file with results that will be saved</span>
<span class="comment">% NOTE: do NOT delete the latter option, leave empty if not needed</span>
<span class="comment">% NOTE: do NOT use to add a suffix specifying the regressors, scaling or masking option, this will be added automatically</span>

<span class="comment">% GET MODEL-SPECIFIC PATHS AND OPTIONS</span>

ery_4a_secondlevel_m6m_s0_a_set_up_paths_always_run_first;
<span class="comment">% NOTE: CHANGE THIS TO THE MODEL-SPECIFIC VERSION OF THIS SCRIPT</span>
<span class="comment">% NOTE: THIS WILL ALSO AUTOMATICALLY CALL A2_SET_DEFAULT_OPTIONS</span>

<span class="comment">% GET DEFAULT OPTIONS IF NOT SET IN A2_SET_DEFAULT_OPTIONS</span>

options_needed = {<span class="string">'dorobust'</span>, <span class="string">'dorobfit_parcelwise'</span>, <span class="string">'myscaling_glm'</span>, <span class="string">'design_matrix_type'</span>, <span class="string">'maskname_glm'</span>};
options_exist = cellfun(@exist, options_needed);

option_default_values = {false, false, <span class="string">'raw'</span>, <span class="string">'onesample'</span>, which(<span class="string">'ery_4a_m6_mask_all_regions.nii'</span>)};

plugin_get_options_for_analysis_script;

<span class="comment">% SET CUSTOM OPTIONS</span>

<span class="comment">% NOTE: only specify if you want to run multiple versions of your model with different options</span>
<span class="comment">% than the defaults you set in your model-specific version of a2_set_default_options.m</span>

<span class="comment">% dorobust = true/false;</span>
dorobfit_parcelwise = true;
<span class="comment">%   csf_wm_covs = true/false;</span>
<span class="comment">%   remove_outliers = true/false;</span>
<span class="comment">% myscaling_glm = 'raw'/'scaled'/'scaled_contrasts';</span>
design_matrix_type = <span class="string">'custom'</span>;
</pre><h2 id="3">CHECK REQUIRED DAT FIELDS</h2><p>-------------------------------------------------------------------------</p><pre class="codeinput"><span class="comment">% List required fields in DAT, in cell array</span>

<span class="keyword">if</span> ~strcmpi(design_matrix_type,<span class="string">'onesample'</span>)

    required_fields = {<span class="string">'BETWEENPERSON'</span>, <span class="string">'contrastnames'</span>, <span class="string">'contrasts'</span> <span class="string">'contrastcolors'</span>, <span class="string">'conditions'</span>, <span class="string">'colors'</span>};

    ok_to_run = plugin_check_required_fields(DAT, required_fields); <span class="comment">% Checks and prints warnings</span>
    <span class="keyword">if</span> ~ok_to_run
        <span class="keyword">return</span>
    <span class="keyword">end</span>

<span class="keyword">else</span>

    required_fields = {<span class="string">'contrastnames'</span>, <span class="string">'contrasts'</span> <span class="string">'contrastcolors'</span>, <span class="string">'conditions'</span>, <span class="string">'colors'</span>};

    ok_to_run = plugin_check_required_fields(DAT, required_fields); <span class="comment">% Checks and prints warnings</span>
    <span class="keyword">if</span> ~ok_to_run
        <span class="keyword">return</span>
    <span class="keyword">end</span>

<span class="keyword">end</span>
</pre><h2 id="4">MASKING</h2><p>-------------------------------------------------------------------------</p><pre class="codeinput">fprintf(<span class="string">'\n\n'</span>);
printhdr(<span class="string">'MASKING IMAGES IF REQUESTED IN OPTIONS'</span>);
fprintf(<span class="string">'\n\n'</span>);

<span class="keyword">if</span> exist(<span class="string">'maskname_glm'</span>, <span class="string">'var'</span>) &amp;&amp; ~isempty(maskname_glm) &amp;&amp; exist(maskname_glm, <span class="string">'file'</span>)
    [~, maskname_short] = fileparts(maskname_glm);
    mask_string = sprintf(<span class="string">'masked with %s'</span>, maskname_short);
    glmmask = fmri_mask_image(maskname_glm, <span class="string">'noverbose'</span>);
    fprintf(<span class="string">'\nMasking results visualization with %s\n\n'</span>, maskname_short);
<span class="keyword">else</span>
    mask_string = sprintf(<span class="string">'without masking'</span>);
    fprintf(<span class="string">'\nShowing results without masking\n\n'</span>);
<span class="keyword">end</span>
</pre><h2 id="5">RUN SECOND LEVEL REGRESSION FOR EACH CONTRAST</h2><p>-------------------------------------------------------------------------</p><pre class="codeinput"><span class="keyword">switch</span> mygroupnamefield

    <span class="keyword">case</span> <span class="string">'contrasts'</span>

<span class="comment">%         kc = 3;</span>

        fprintf(<span class="string">'\nRUNNING SECOND LEVEL REGRESSIONS ON FIRST LEVEL CONTRASTS\n\n'</span>);

    <span class="keyword">case</span> <span class="string">'conditions'</span>

<span class="comment">%         kc = 3;</span>

        fprintf(<span class="string">'\nRUNNING SECOND LEVEL REGRESSIONS ON FIRST LEVEL CONDITIONS\n\n'</span>);

    <span class="keyword">otherwise</span>

        error(<span class="string">'\ninvalid option "%s" defined in mygroupnamefield variable, choose between "contrasts" and "conditions"\n\n'</span>,mygroupnamefield)

<span class="keyword">end</span>

<span class="keyword">if</span> ~dorobfit_parcelwise
    regression_stats_results = cell(1, 3);
<span class="keyword">else</span>
    parcelwise_stats_results = cell(1, 3);
<span class="keyword">end</span>

<span class="keyword">for</span> c = 1:3

    <span class="comment">% GET DESIGN MATRIX FOR THIS CONTRAST OR CONDITION</span>
    <span class="comment">% ---------------------------------------------------------------------</span>

    <span class="keyword">switch</span> mygroupnamefield

        <span class="keyword">case</span> <span class="string">'contrasts'</span>
            fprintf(<span class="string">'\n\n'</span>);
            printhdr([<span class="string">'CONTRAST #'</span>, num2str(c), <span class="string">': '</span>, upper(DAT.contrastnames{c})]);
            fprintf(<span class="string">'\n\n'</span>);

        <span class="keyword">case</span> <span class="string">'conditions'</span>
            fprintf(<span class="string">'\n\n'</span>);
            printhdr([<span class="string">'CONTRAST #'</span>, num2str(c), <span class="string">': '</span>, upper(DAT.conditions{c})]);
            fprintf(<span class="string">'\n\n'</span>);

    <span class="keyword">end</span>

    fprintf(<span class="string">'\n\n'</span>);
    printhdr(<span class="string">'Building design matrix'</span>);
    fprintf(<span class="string">'\n\n'</span>);

    groupnames_string = <span class="string">'intercept'</span>;

    <span class="keyword">switch</span> design_matrix_type

        <span class="keyword">case</span> <span class="string">'custom'</span>

            <span class="comment">% Define design matrix X "design_matrix"</span>
            <span class="comment">% Use custom matrix for each condition/contrast</span>
            <span class="keyword">if</span> c &lt; 4
                table_obj = DAT.BETWEENPERSON.(mygroupnamefield){c}(:,1);
            <span class="keyword">else</span>
                table_obj = DAT.BETWEENPERSON.(mygroupnamefield){c};
            <span class="keyword">end</span>
            groupnames = table_obj.Properties.VariableNames;
            X = table2array(table_obj);
            idx_nan = ~isnan(X);
            idx_nan = ~(sum(idx_nan,2) &lt; size(idx_nan,2)); <span class="comment">% at least one column of X contains NaN</span>
            imgs_nan = 1:size(X,1);
            imgs_nan = imgs_nan(idx_nan');
            X = X(idx_nan,:);

            <span class="keyword">for</span> name = 1:size(groupnames,2)
                groupnames_string = [groupnames_string, <span class="string">' '</span>, groupnames{name}];
            <span class="keyword">end</span>

        <span class="keyword">case</span> <span class="string">'group'</span>

            <span class="comment">% Use 'groups' single regressor</span>
            <span class="keyword">if</span> ~isempty(DAT.BETWEENPERSON.group)
                group = DAT.BETWEENPERSON.group;
                groupnames = {<span class="string">'group'</span>};
                X = group;
                imgs_nan = [];
                groupnames_string = [groupnames_string, <span class="string">' '</span>, groupnames];
            <span class="keyword">else</span>
                error(<span class="string">'\nGroup not defined in DAT.BETWEENPERSON.group, which is required for option "%s" defined in design_matrix_type\n'</span>, design_matrix_type);
            <span class="keyword">end</span>

        <span class="keyword">case</span> <span class="string">'onesample'</span>

                <span class="comment">% Use intercept only</span>
                <span class="keyword">switch</span> mygroupnamefield
                    <span class="keyword">case</span> <span class="string">'conditions'</span>
                        X = ones((size(DAT.imgs{c},1)),1);
                    <span class="keyword">case</span> <span class="string">'contrasts'</span>
                        X = ones((size(DAT.gray_white_csf_contrasts{c},1)),1);
                <span class="keyword">end</span>
                groupnames = {<span class="string">'intercept'</span>};
                imgs_nan = [];

        <span class="keyword">otherwise</span>

            error(<span class="string">'\ninvalid option "%s" defined in design_matrix_type variable, choose between "group", "custom", or "onesample"\n\n'</span>, design_matrix_type);

    <span class="keyword">end</span>

    fprintf(<span class="string">'\nREGRESSOR(S): %s\n\n'</span>, groupnames_string);

    <span class="comment">% SELECT DATA FOR THIS CONTRAST/CONDITION</span>
    <span class="comment">% ---------------------------------------------------------------------</span>

    fprintf(<span class="string">'\n\n'</span>);
    printhdr(<span class="string">'Scaling data if requested in options'</span>);
    fprintf(<span class="string">'\n\n'</span>);

    <span class="keyword">switch</span> mygroupnamefield

        <span class="keyword">case</span> <span class="string">'contrasts'</span>

            <span class="keyword">switch</span> myscaling_glm

                <span class="keyword">case</span> <span class="string">'raw'</span>
                    fprintf(<span class="string">'\nContrast calculated on raw (unscaled) condition images used in second-level GLM\n\n'</span>);
                    scaling_string = <span class="string">'no_scaling'</span>;
                    cat_obj = DATA_OBJ_CON{c};
                    <span class="keyword">if</span> imgs_nan
                        cat_obj = cat_obj.get_wh_image(imgs_nan);
                    <span class="keyword">end</span>

                <span class="keyword">case</span> <span class="string">'scaled'</span>
                    fprintf(<span class="string">'\nContrast calculated on z-scored condition images used in second-level GLM\n\n'</span>);
                    scaling_string = <span class="string">'scaling_z_score_conditions'</span>;
                    cat_obj = DATA_OBJ_CONsc{c};
                    <span class="keyword">if</span> imgs_nan
                        cat_obj = cat_obj.get_wh_image(imgs_nan);
                    <span class="keyword">end</span>

                <span class="keyword">case</span> <span class="string">'scaled_contrasts'</span>
                    fprintf(<span class="string">'\nl2norm scaled contrast images used in second-level GLM\n\n'</span>);
                    scaling_string = <span class="string">'scaling_l2norm_contrasts'</span>;
                    cat_obj = DATA_OBJ_CONscc{c};
                    <span class="keyword">if</span> imgs_nan
                        cat_obj = cat_obj.get_wh_image(imgs_nan);
                    <span class="keyword">end</span>

                <span class="keyword">otherwise</span>
                    error(<span class="string">'\nInvalid option "%s" defined in myscaling_glm variable in a2_set_default_options script, choose between "raw", "scaled", or "scaled_constrast" given option "%s" defined in mygroupnamefield variable\n\n'</span>, myscaling_glm, mygroupnamefield);

            <span class="keyword">end</span>

        <span class="keyword">case</span> <span class="string">'conditions'</span>

            <span class="keyword">switch</span> myscaling_glm

                <span class="keyword">case</span> <span class="string">'raw'</span>
                    fprintf(<span class="string">'\nRaw (unscaled) condition images used in second-level GLM\n\n'</span>);
                    scaling_string = <span class="string">'no_scaling'</span>;
                    cat_obj = DATA_OBJ{c};
                    <span class="keyword">if</span> imgs_nan
                        cat_obj = cat_obj.get_wh_image(imgs_nan);
                    <span class="keyword">end</span>

                <span class="keyword">case</span> <span class="string">'scaled'</span>
                    fprintf(<span class="string">'\nZ-scored condition images used in second-level GLM\n\n'</span>);
                    scaling_string = <span class="string">'scaling_z_score_conditions'</span>;
                    cat_obj = DATA_OBJsc{c};
                    <span class="keyword">if</span> imgs_nan
                        cat_obj = cat_obj.get_wh_image(imgs_nan);
                    <span class="keyword">end</span>

                <span class="keyword">case</span> <span class="string">'scaled_contrasts'</span>
                    error(<span class="string">'\nInvalid combination of option "%s" defined in myscaling_glm_variable in a2_set_default_options script and option "%s" defined in mygroupnamefield variable, choose between "raw" and "scaled" options\n\n'</span>,myscaling_glm,mygroupnamefield);

                <span class="keyword">otherwise</span>
                    error(<span class="string">'\nInvalid option "%s" defined in myscaling_glm variable in a2_set_default_options script, choose between "raw",  and "scaled", given option "%s" defined in mygroupnamefield variable\n\n'</span>, myscaling_glm, mygroupnamefield);

            <span class="keyword">end</span>

    <span class="keyword">end</span> <span class="comment">% switch mygroupnamefield - contrasts or conditions</span>


    <span class="comment">% FORMAT AND ATTACH DESIGN MATRIX</span>
    <span class="comment">% ---------------------------------------------------------------------</span>

    fprintf(<span class="string">'\n\n'</span>);
    printhdr(<span class="string">'Checking design matrix'</span>);
    fprintf(<span class="string">'\n\n'</span>);

    <span class="keyword">if</span> ~strcmpi(design_matrix_type,<span class="string">'onesample'</span>)

        <span class="comment">% Confirm design_matrix is 1, -1, or mean-centered</span>
        meancentered = ~(abs(mean(X)) &gt; 1000 * eps);
        effectscoded = all(X == 1 | X == -1 | X == 0, 1);
        isconstant = all(X == mean(X, 1), 1);
        vifs = getvif(X);

        <span class="keyword">if</span> any(isconstant)

            fprintf(<span class="string">'\n'</span>);
            warning(<span class="string">'An intercept appears to be added manually. Do not include an intercept - it will be added automatically.'</span>);
            warning(<span class="string">'Skipping this contrast.'</span>);
            fprintf(<span class="string">'\n'</span>);

            <span class="keyword">continue</span>
        <span class="keyword">end</span>

        <span class="comment">% Report</span>
        design_table = table;
        design_table.Mean = mean(X)';
        design_table.Var = var(X)';
        design_table.EffectsCode = effectscoded';
        design_table.VIF = vifs';
        design_table.Properties.RowNames = groupnames';
        disp(design_table)
        disp(<span class="string">' '</span>);

        <span class="keyword">if</span> any(~meancentered &amp; ~effectscoded)
            fprintf(<span class="string">'\n'</span>);
            warning(<span class="string">'Some columns are not mean-centered or effects coded. Intercept may not be interpretable'</span>);
            fprintf(<span class="string">'\nColumns: '</span>)
            fprintf(<span class="string">'%d \n'</span>, find(~meancentered &amp; ~effectscoded));
        <span class="keyword">else</span>
            fprintf(<span class="string">'\nChecked OK: All columns mean-centered or are effects-coded [1 -1 0]\n\n'</span>);
        <span class="keyword">end</span>

        <span class="keyword">if</span> any(vifs &gt; 2)
            fprintf(<span class="string">'\n'</span>);
            warning(<span class="string">'Some regressors have high variance inflation factors. Parameters might be poorly estimated or uninterpretable.'</span>);
            fprintf(<span class="string">'\n'</span>);
        <span class="keyword">else</span>
            fprintf(<span class="string">'\nChecked OK: VIFs for all columns are &lt; 2\n\n'</span>);
        <span class="keyword">end</span>

    <span class="keyword">else</span>
        design_table = table;
        design_table.Mean = mean(X)';
        design_table.Var = var(X)';

    <span class="keyword">end</span> <span class="comment">% if loop design_matrix_type</span>

    cat_obj.X = X;

    <span class="comment">% SANITY CHECK ON REGRESSORS, SKIP CONTRAST IF NEEDED</span>
    <span class="comment">% ---------------------------------------------------------------------</span>

    <span class="keyword">if</span> ~strcmpi(design_matrix_type,<span class="string">'onesample'</span>)

        <span class="keyword">if</span> all(cat_obj.X &gt; 0) || all(cat_obj.X &lt; 0)
            <span class="comment">% Only positive or negative weights - nothing to compare</span>

            fprintf(<span class="string">'\n'</span>);
            warning(<span class="string">'Only positive or negative regressor values - bad design, please check'</span>);
            fprintf(<span class="string">'\n'</span>);

            <span class="keyword">continue</span>
        <span class="keyword">end</span>

    <span class="keyword">end</span>

    <span class="comment">% RUN GLM MODEL</span>
    <span class="comment">% ---------------------------------------------------------------------</span>

    <span class="comment">% VOXEL-WISE</span>

    <span class="keyword">if</span> ~dorobfit_parcelwise

        <span class="keyword">if</span> dorobust
            robuststring = <span class="string">'robust'</span>;
            regresstime = tic;
        <span class="keyword">else</span>
            robuststring = <span class="string">'norobust'</span>;
        <span class="keyword">end</span>

        fprintf(<span class="string">'\n\n'</span>);
        printhdr([<span class="string">'Running voxel-wise '</span>, robuststring <span class="string">' regression'</span>]);
        fprintf(<span class="string">'\n\n'</span>);

        <span class="keyword">if</span> ~strcmpi(design_matrix_type,<span class="string">'onesample'</span>)
            <span class="comment">% out.t has t maps for all regressors, intercept is last</span>
            <span class="keyword">switch</span> mygroupnamefield
                <span class="keyword">case</span> <span class="string">'contrasts'</span>
                    regression_stats = regress(cat_obj, .05, <span class="string">'unc'</span>, robuststring, <span class="string">'analysis_name'</span>, DAT.contrastnames{c}, <span class="string">'variable_names'</span>, groupnames, <span class="string">'nodisplay'</span>);
                <span class="keyword">case</span> <span class="string">'conditions'</span>
                    regression_stats = regress(cat_obj, .05, <span class="string">'unc'</span>, robuststring, <span class="string">'analysis_name'</span>, DAT.conditions{c}, <span class="string">'variable_names'</span>, groupnames, <span class="string">'nodisplay'</span>);
            <span class="keyword">end</span>
        <span class="keyword">else</span>
            <span class="comment">% out.t has t maps for intercept only</span>
            <span class="keyword">switch</span> mygroupnamefield
                <span class="keyword">case</span> <span class="string">'contrasts'</span>
                    regression_stats = regress(cat_obj, .05, <span class="string">'unc'</span>, robuststring, <span class="string">'analysis_name'</span>, DAT.contrastnames{c}, <span class="string">'variable_names'</span>, groupnames, <span class="string">'nointercept'</span>, <span class="string">'nodisplay'</span>);
                <span class="keyword">case</span> <span class="string">'conditions'</span>
                    regression_stats = regress(cat_obj, .05, <span class="string">'unc'</span>, robuststring, <span class="string">'analysis_name'</span>, DAT.conditions{c}, <span class="string">'variable_names'</span>, groupnames, <span class="string">'nointercept'</span>, <span class="string">'nodisplay'</span>);
            <span class="keyword">end</span>
        <span class="keyword">end</span>

        <span class="comment">% Make sure variable types are right data formats</span>
        regression_stats.design_table = design_table;
        regression_stats.t = enforce_variable_types(regression_stats.t);
        regression_stats.b = enforce_variable_types(regression_stats.b);
        regression_stats.df = enforce_variable_types(regression_stats.df);
        regression_stats.sigma = enforce_variable_types(regression_stats.sigma);

        <span class="comment">% add analysis name, regressor names and other meta-data</span>
        <span class="keyword">switch</span> mygroupnamefield
            <span class="keyword">case</span> <span class="string">'contrasts'</span>
                regression_stats.contrastname = DAT.contrastnames{c};
                regression_stats.contrast = DAT.contrasts(c, :);
                regression_stats.analysis_name = DAT.contrastnames{c};
            <span class="keyword">case</span> <span class="string">'conditions'</span>
                regression_stats.contrastname = DAT.conditions{c};
                regression_stats.contrast = 1;
                regression_stats.analysis_name = DAT.conditions{c};
        <span class="keyword">end</span>

        <span class="comment">% add names for variables</span>
        <span class="keyword">if</span> ~strcmpi(design_matrix_type,<span class="string">'onesample'</span>)
            regression_stats.variable_names = [groupnames {<span class="string">'intercept'</span>}];
        <span class="keyword">else</span>
            regression_stats.variable_names = groupnames;
        <span class="keyword">end</span>

        <span class="comment">% PLOT ORTHVIEWS (MASKED IF SPECIFIED IN MASKNAME_GLM OPTION)</span>
        <span class="comment">% --------------------------------------------------------------------</span>

        fprintf (<span class="string">'\nORTHVIEWS GLM RESULTS AT UNCORRECTED p &lt; 0.05, EFFECT: %s, REGRESSOR(S): %s, %s, SCALING: %s\n\n'</span>, regression_stats.analysis_name, groupnames_string, mask_string, scaling_string);

        t = regression_stats.t;
            <span class="keyword">if</span> maskname_short
                t = apply_mask(t,glmmask);
            <span class="keyword">end</span>
        orthviews(t);
            <span class="keyword">for</span> kk = 1:length(regression_stats.variable_names)
                <span class="keyword">switch</span> mygroupnamefield
                    <span class="keyword">case</span> <span class="string">'contrasts'</span>
                        spm_orthviews_name_axis([regression_stats.variable_names{kk},<span class="string">' '</span>,DAT.contrastnames{c}], kk);
                    <span class="keyword">case</span> <span class="string">'conditions'</span>
                        spm_orthviews_name_axis([regression_stats.variable_names{kk},<span class="string">' '</span>,DAT.conditions{c}], kk);
                <span class="keyword">end</span>
            <span class="keyword">end</span>
        drawnow;snapnow;

        <span class="comment">% KEEP RESULTS OBJECTS IN CELL ARRAY FOR SAVING</span>
        <span class="comment">% ---------------------------------------------------------------------</span>

        regression_stats_results{c} = regression_stats;

        <span class="keyword">if</span> exist(maskname_glm,<span class="string">'file'</span>)
            regression_stats_results{c}.maskname = maskname_glm;
        <span class="keyword">end</span>

        <span class="keyword">if</span> dorobust
            fprintf(<span class="string">'\nCumulative run time:\n'</span>), toc(regresstime);
        <span class="keyword">end</span>

    <span class="comment">% PARCEL-WISE</span>

    <span class="keyword">else</span>

        fprintf(<span class="string">'\n\n'</span>);
        printhdr(<span class="string">'Running parcel-wise robust regression'</span>);
        fprintf(<span class="string">'\n\n'</span>);

        <span class="keyword">if</span> csf_wm_covs &amp;&amp; remove_outliers
            parcelwise_stats = robfit_parcelwise(cat_obj,<span class="string">'names'</span>, groupnames,<span class="string">'csf_wm_covs'</span>,true,<span class="string">'remove_outliers'</span>,true,<span class="string">'doplot'</span>,false);
        <span class="keyword">elseif</span> csf_wm_covs &amp;&amp; ~remove_outliers
            parcelwise_stats = robfit_parcelwise(cat_obj,<span class="string">'names'</span>, groupnames,<span class="string">'csf_wm_covs'</span>,true,<span class="string">'remove_outliers'</span>,false,<span class="string">'doplot'</span>,false);
        <span class="keyword">elseif</span> ~csf_wm_covs &amp;&amp; remove_outliers
            parcelwise_stats = robfit_parcelwise(cat_obj,<span class="string">'names'</span>, groupnames,<span class="string">'csf_wm_covs'</span>,false,<span class="string">'remove_outliers'</span>,true,<span class="string">'doplot'</span>,false);
        <span class="keyword">else</span>
            parcelwise_stats = robfit_parcelwise(cat_obj,<span class="string">'names'</span>, groupnames,<span class="string">'doplot'</span>,false);
        <span class="keyword">end</span>


        <span class="comment">% add design table</span>
        parcelwise_stats.design_table = design_table;

        <span class="comment">% add analysis name, regressor names, and other meta-data</span>
        <span class="keyword">switch</span> mygroupnamefield
            <span class="keyword">case</span> <span class="string">'contrasts'</span>
                parcelwise_stats.contrastname = DAT.contrastnames{c};
                parcelwise_stats.contrast = DAT.contrasts(c, :);
                parcelwise_stats.analysis_name = DAT.contrastnames{c};
            <span class="keyword">case</span> <span class="string">'conditions'</span>
                parcelwise_stats.contrastname = DAT.conditions{c};
                parcelwise_stats.contrast = 1;
                parcelwise_stats.analysis_name = DAT.conditions{c};
        <span class="keyword">end</span>

        <span class="comment">% add names for variables</span>
        <span class="keyword">if</span> ~strcmpi(design_matrix_type,<span class="string">'onesample'</span>)
            parcelwise_stats.variable_names = [groupnames {<span class="string">'Intercept'</span>}];
        <span class="keyword">else</span>
            parcelwise_stats.variable_names = groupnames;
        <span class="keyword">end</span>

        <span class="comment">% PLOT PARCELWISE SPECIFIC WEIGHTS AND DIAGNOSTICS</span>
        <span class="comment">% --------------------------------------------------------------------</span>
        fprintf(<span class="string">'\nPlotting parcel weights and diagnostics\n\n'</span>);

        create_figure(<span class="string">'parcelwise weights and metrics'</span>, 2, 2);
        set(gcf, <span class="string">'WindowState'</span>,<span class="string">'maximized'</span>);
        xlabel(<span class="string">'Image'</span>); ylabel(<span class="string">'Weights'</span>);
        errorbar(mean(parcelwise_stats.weights), std(parcelwise_stats.weights), <span class="string">'bo'</span>, <span class="string">'MarkerFaceColor'</span>, [0 0 .5])
        title(<span class="string">'Mean weights across parcels (s.d. error bars) per image'</span>);
        axis <span class="string">tight</span>;

        subplot(2, 2, 2);
        imagesc(parcelwise_stats.weights);
        xlabel(<span class="string">'Image'</span>); ylabel(<span class="string">'Parcel'</span>);
        title(<span class="string">'Weights by parcel'</span>);
        colorbar;
        axis <span class="string">tight</span>; set(gca, <span class="string">'YDir'</span>, <span class="string">'Reverse'</span>);

        subplot(2, 2, 3);
        xlabel(<span class="string">'Image'</span>); ylabel(<span class="string">'Z(Weights)'</span>);
        errorbar(zscore(mean(parcelwise_stats.weights)), ste(parcelwise_stats.weights), <span class="string">'bo-'</span>, <span class="string">'MarkerFaceColor'</span>, [0 0 .5], <span class="string">'LineWidth'</span>, 2)
        title(<span class="string">'Mean weights (s.e. error bars) and quality metrics'</span>);
        plot(zscore(parcelwise_stats.individual_metrics.gm_L1norm), <span class="string">'LineWidth'</span>, 2);
        plot(zscore(parcelwise_stats.individual_metrics.csf_L1norm), <span class="string">'LineWidth'</span>, 2);
        plot(zscore(parcelwise_stats.ind_quality_dat.Mahal_corr), <span class="string">'LineWidth'</span>, 2);
        plot(zscore(parcelwise_stats.ind_quality_dat.Mahal_cov), <span class="string">'LineWidth'</span>, 2);
        legend({<span class="string">'Z(Weights)'</span> <span class="string">'Z(GM L1 norm)'</span> <span class="string">'Z(CSF L1 norm)'</span> <span class="string">'Mahal corr dist'</span> <span class="string">'Mahal cov dist'</span>});
        axis <span class="string">tight</span>;

        <span class="comment">% mark off who are outliers</span>
        wh_out = find(parcelwise_stats.outliers_uncorr);
        <span class="keyword">for</span> i = 1:length(wh_out)

            hh = plot_vertical_line(wh_out(i));
            set(hh, <span class="string">'Color'</span>, <span class="string">'r'</span>, <span class="string">'LineStyle'</span>, <span class="string">'--'</span>);

            <span class="keyword">if</span> i == 1
                    legend({<span class="string">'Z(Weights)'</span> <span class="string">'Z(GM L1 norm)'</span> <span class="string">'Z(CSF L1 norm)'</span> <span class="string">'Mahal corr dist'</span> <span class="string">'Mahal cov dist'</span> <span class="string">'Mah. outliers p&lt;.05 uncor'</span>});
            <span class="keyword">end</span>
        <span class="keyword">end</span>

        subplot(2, 2, 4)
        plot_correlation_matrix(parcelwise_stats.datmatrix, <span class="string">'dofigure'</span>, false);
        title(<span class="string">'inter-parcel correlations across images'</span>);
        drawnow, snapnow;


        <span class="comment">% PLOT MONTAGE (MASKED IF SPECIFIED IN MASKNAME_GLM OPTION)</span>
        <span class="comment">% ---------------------------------------------------------------------</span>

        fprintf (<span class="string">'\nMONTAGE PARCELWISE GLM RESULTS AT UNCORRECTED p &lt; 0.05, EFFECT: %s, REGRESSOR(S): %s, %s, SCALING: %s\n\n'</span>, parcelwise_stats.analysis_name, groupnames_string, mask_string, scaling_string);

        num_effects = size(parcelwise_stats.t_obj.dat, 2); <span class="comment">% number of regressors</span>
        o2 = canlab_results_fmridisplay([], <span class="string">'multirow'</span>, num_effects, <span class="string">'outline'</span>, <span class="string">'linewidth'</span>, 0.5, <span class="string">'splitcolor'</span>,{[.1 .8 .8] [.1 .1 .8] [.9 .4 0] [1 1 0]}, <span class="string">'overlay'</span>, <span class="string">'mni_icbm152_t1_tal_nlin_sym_09a_brainonly.img'</span>);

        <span class="keyword">for</span> j = 1:num_effects

            tj = get_wh_image(parcelwise_stats.t_obj, j);
                <span class="keyword">if</span> maskname_short
                    tj = apply_mask(tj, glmmask);
                <span class="keyword">end</span>
            tj = threshold(tj, .05, <span class="string">'unc'</span>);

            o2 = addblobs(o2, region(tj), <span class="string">'wh_montages'</span>, (2*j)-1:2*j);
            o2 = title_montage(o2, 2*j, [parcelwise_stats.analysis_name <span class="string">' '</span> parcelwise_stats.variable_names{j} <span class="string">' '</span> mask_string <span class="string">' '</span> scaling_string]);

        <span class="keyword">end</span>

        figtitle = sprintf(<span class="string">'%s_05_unc_montage_%s_%s_%s'</span>, parcelwise_stats.analysis_name, groupnames_string, mask_string, scaling_string);
        set(gcf, <span class="string">'Tag'</span>, figtitle, <span class="string">'WindowState'</span>,<span class="string">'maximized'</span>);
        drawnow, snapnow;
            <span class="keyword">if</span> save_figures_glm <span class="comment">% corrected save_figures into save_figures_glm</span>
                plugin_save_figure;
            <span class="keyword">end</span>
        clear <span class="string">o2</span>, clear <span class="string">figtitle</span>, clear <span class="string">j</span>, clear <span class="string">tj</span>

        <span class="comment">% KEEP RESULTS OBJECTS IN CELL ARRAY FOR SAVING</span>
        <span class="comment">% ---------------------------------------------------------------------</span>

        parcelwise_stats_results{c} = parcelwise_stats;

        <span class="keyword">if</span> exist(maskname_glm,<span class="string">'file'</span>)
            parcelwise_stats_results{c}.maskname = maskname_glm;
        <span class="keyword">end</span>

    <span class="keyword">end</span> <span class="comment">% if loop voxel- versus parcelwise</span>

<span class="keyword">end</span>  <span class="comment">% for loop over contrasts or conditions</span>
</pre><h2 id="6">SAVE RESULTS</h2><p>-------------------------------------------------------------------------</p><pre class="codeinput">fprintf(<span class="string">'\n\n'</span>);
printhdr(<span class="string">'SAVING GLM RESULTS'</span>);
fprintf(<span class="string">'\n\n'</span>);

<span class="keyword">if</span> ~dorobfit_parcelwise
        savefilenamedata = fullfile(resultsdir, [<span class="string">'regression_stats_and_maps_'</span>, mygroupnamefield, <span class="string">'_'</span>, scaling_string, <span class="string">'_'</span>, results_suffix, <span class="string">'.mat'</span>]);
        save(savefilenamedata, <span class="string">'regression_stats_results'</span>, <span class="string">'-v7.3'</span>);
        fprintf(<span class="string">'\nSaved regression_stats_results for %s\n'</span>, mygroupnamefield);

<span class="keyword">else</span>
        savefilenamedata = fullfile(resultsdir, [<span class="string">'parcelwise_stats_and_maps_'</span>, mygroupnamefield, <span class="string">'_'</span>, scaling_string, <span class="string">'_'</span>, results_suffix, <span class="string">'.mat'</span>]);
        save(savefilenamedata, <span class="string">'parcelwise_stats_results'</span>, <span class="string">'-v7.3'</span>);
        fprintf(<span class="string">'\nSaved parcelwise_stats_results for %s\n'</span>, mygroupnamefield);
<span class="keyword">end</span>

fprintf(<span class="string">'\nFilename: %s\n'</span>, savefilenamedata);
</pre><p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2021a</a><br></p></div><!--
##### SOURCE BEGIN #####
%% prep_3a_run_second_level_regression_and_save_parcelregression_covariates_intensity.m
%
%
% USAGE
%
% This script 
% 1) runs second⁻level (i.e. across subjects) regression analyses
%   for each within-subject CONTRAST or CONDITION registered in the DAT
%   structure, either
%       a) voxel-wise, calling CANlab's regress() function under the hood,
%       including its robust regression option if specified
%       b) parcel-wise, calling CANlab's robfit_parcelwise() function under the
%       hood, which is robust by default
% 2) saves the results using standard naming and location
% 
% Run this script with Matlab's publish function to generate html report of results:
% publish('prep_3a_run_second_level_regression_and_save','outputDir',htmlsavedir)
%
% To get results reports after bootstrapping, publish
% c2a_second_level_regression
%
%
% OPTIONS
%
% NOTE: 
% defaults are specified in a2_set_default_options for any given model,
% but if you want to run the same model with different options (for example
% voxel- and parcelwise regression), you can make a copy of this script with
% a letter index (e.g. _s6a_) and change the default option here
%
% - dorobust : robust regression or OLS (true/false)
% - dorobfit_parcelwise: voxel- or parcelwise regression (true/false) - % OPTION ADDED BY @LUKASVO76 MAY 2022
%       - csf_wm_covs: true adds global wm & csf regressors at second level
%       - remove_outliers: true removes outlier images/subjects based on mahalanobis distance 
% - myscaling_glm: 'raw', 'scaled', or 'scaled_contrasts' (defined in a2_set_..., image scaling done in prep_2_... and prep_3_... data load)
% - maskname_glm: 
%       - default use of sparse gray matter mask
%       - model-specific maskdir defined in a_set_up_paths_always_run_first script
%       - if you do not want to mask, change to []
%       - if you want to use a custom mask, put it in maskdir and change name here
%       - only used for visualization of uncorrected results in this script
% - design_matrix_type: 'group', 'custom', or 'onesample'
%                       Group: use DAT.BETWEENPERSON.group or DAT.BETWEENPERSON.contrasts{c}.group;
%                       Custom: use all columns of table object DAT.BETWEENPERSON.contrasts{c};
%                       Onesample: use constant (i.e. intercept) only
%
%       - 'group' option 
%           Assuming that groups are concatenated in contrast image lists, and
%           regressor values of 1 or -1 will specify the group identity for each
%           image. Requires DAT.BETWEENPERSON.group field specifying group membership for
%           each image.
%
%       - 'custom' option: 
%           Can enter a multi-column design matrix for each contrast
%           Design matrix can be different for each contrast
%
%       - 'onesample' option:
%           Only adds intercept, hence performs a one-sample t-test on contrast
%           images across all subjects, similarly to c_univariate_contrast_maps_
%           scripts, but with more flexible options including scaling and robustfit
%   
%       OPTION ADDED BY @LUKASVO76 MAY 2022
%
%       NOTE: To set up group and custom variables, see prep_1b_prep_behavioral_data
%
% MANDATORY OPTIONS TO BE SPECIFIED IN THIS SCRIPT
%
% - mygroupfieldname: 'contrasts' or 'conditions'
% - results_suffix: name to add to results file to specify in case of multiple versions of model, e.g. 'covariate_rating'
%
%__________________________________________________________________________
%
% revamped by: Lukas Van Oudenhove
% date:   Dartmouth, May, 2022
%
%__________________________________________________________________________
% @(#)% prep_3a_run_second_level_regression_and_save.m         v3.2
% last modified: 2022/09/02


%% GET AND SET OPTIONS
% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-

% SET MANDATORY OPTIONS

mygroupnamefield = 'contrasts'; 
results_suffix = 'covintensity_rating'; % adds a suffix of your choice to .mat file with results that will be saved
% NOTE: do NOT delete the latter option, leave empty if not needed
% NOTE: do NOT use to add a suffix specifying the regressors, scaling or masking option, this will be added automatically

% GET MODEL-SPECIFIC PATHS AND OPTIONS

ery_4a_secondlevel_m6m_s0_a_set_up_paths_always_run_first;
% NOTE: CHANGE THIS TO THE MODEL-SPECIFIC VERSION OF THIS SCRIPT
% NOTE: THIS WILL ALSO AUTOMATICALLY CALL A2_SET_DEFAULT_OPTIONS

% GET DEFAULT OPTIONS IF NOT SET IN A2_SET_DEFAULT_OPTIONS

options_needed = {'dorobust', 'dorobfit_parcelwise', 'myscaling_glm', 'design_matrix_type', 'maskname_glm'};
options_exist = cellfun(@exist, options_needed); 

option_default_values = {false, false, 'raw', 'onesample', which('ery_4a_m6_mask_all_regions.nii')};

plugin_get_options_for_analysis_script;

% SET CUSTOM OPTIONS

% NOTE: only specify if you want to run multiple versions of your model with different options
% than the defaults you set in your model-specific version of a2_set_default_options.m

% dorobust = true/false;
dorobfit_parcelwise = true;
%   csf_wm_covs = true/false;
%   remove_outliers = true/false;
% myscaling_glm = 'raw'/'scaled'/'scaled_contrasts';
design_matrix_type = 'custom';


%% CHECK REQUIRED DAT FIELDS
% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-

% List required fields in DAT, in cell array

if ~strcmpi(design_matrix_type,'onesample')
    
    required_fields = {'BETWEENPERSON', 'contrastnames', 'contrasts' 'contrastcolors', 'conditions', 'colors'};

    ok_to_run = plugin_check_required_fields(DAT, required_fields); % Checks and prints warnings
    if ~ok_to_run
        return
    end
    
else
    
    required_fields = {'contrastnames', 'contrasts' 'contrastcolors', 'conditions', 'colors'};

    ok_to_run = plugin_check_required_fields(DAT, required_fields); % Checks and prints warnings
    if ~ok_to_run
        return
    end
    
end


%% MASKING
% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-

fprintf('\n\n');
printhdr('MASKING IMAGES IF REQUESTED IN OPTIONS');
fprintf('\n\n');

if exist('maskname_glm', 'var') && ~isempty(maskname_glm) && exist(maskname_glm, 'file')
    [~, maskname_short] = fileparts(maskname_glm);
    mask_string = sprintf('masked with %s', maskname_short);
    glmmask = fmri_mask_image(maskname_glm, 'noverbose'); 
    fprintf('\nMasking results visualization with %s\n\n', maskname_short);
else
    mask_string = sprintf('without masking');
    fprintf('\nShowing results without masking\n\n');
end  


%% RUN SECOND LEVEL REGRESSION FOR EACH CONTRAST
% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-

switch mygroupnamefield
    
    case 'contrasts'

%         kc = 3;
       
        fprintf('\nRUNNING SECOND LEVEL REGRESSIONS ON FIRST LEVEL CONTRASTS\n\n');
        
    case 'conditions'
        
%         kc = 3;
       
        fprintf('\nRUNNING SECOND LEVEL REGRESSIONS ON FIRST LEVEL CONDITIONS\n\n');
        
    otherwise
        
        error('\ninvalid option "%s" defined in mygroupnamefield variable, choose between "contrasts" and "conditions"\n\n',mygroupnamefield)

end

if ~dorobfit_parcelwise
    regression_stats_results = cell(1, 3);
else
    parcelwise_stats_results = cell(1, 3);
end

for c = 1:3
    
    % GET DESIGN MATRIX FOR THIS CONTRAST OR CONDITION
    % REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
    
    switch mygroupnamefield
        
        case 'contrasts'
            fprintf('\n\n');
            printhdr(['CONTRAST #', num2str(c), ': ', upper(DAT.contrastnames{c})]);
            fprintf('\n\n');
            
        case 'conditions'
            fprintf('\n\n');
            printhdr(['CONTRAST #', num2str(c), ': ', upper(DAT.conditions{c})]);
            fprintf('\n\n');
    
    end
      
    fprintf('\n\n');
    printhdr('Building design matrix');
    fprintf('\n\n');
    
    groupnames_string = 'intercept';
    
    switch design_matrix_type
        
        case 'custom'
            
            % Define design matrix X "design_matrix"
            % Use custom matrix for each condition/contrast
            if c < 4
                table_obj = DAT.BETWEENPERSON.(mygroupnamefield){c}(:,1);
            else
                table_obj = DAT.BETWEENPERSON.(mygroupnamefield){c}; 
            end
            groupnames = table_obj.Properties.VariableNames;
            X = table2array(table_obj);
            idx_nan = ~isnan(X);
            idx_nan = ~(sum(idx_nan,2) < size(idx_nan,2)); % at least one column of X contains NaN
            imgs_nan = 1:size(X,1);
            imgs_nan = imgs_nan(idx_nan');
            X = X(idx_nan,:);
            
            for name = 1:size(groupnames,2)
                groupnames_string = [groupnames_string, ' ', groupnames{name}];
            end
            
        case 'group'
            
            % Use 'groups' single regressor
            if ~isempty(DAT.BETWEENPERSON.group)
                group = DAT.BETWEENPERSON.group;
                groupnames = {'group'};
                X = group;
                imgs_nan = [];
                groupnames_string = [groupnames_string, ' ', groupnames];
            else
                error('\nGroup not defined in DAT.BETWEENPERSON.group, which is required for option "%s" defined in design_matrix_type\n', design_matrix_type);
            end

        case 'onesample'
            
                % Use intercept only
                switch mygroupnamefield
                    case 'conditions'
                        X = ones((size(DAT.imgs{c},1)),1);
                    case 'contrasts'
                        X = ones((size(DAT.gray_white_csf_contrasts{c},1)),1);
                end
                groupnames = {'intercept'};
                imgs_nan = [];
            
        otherwise
            
            error('\ninvalid option "%s" defined in design_matrix_type variable, choose between "group", "custom", or "onesample"\n\n', design_matrix_type);
            
    end
    
    fprintf('\nREGRESSOR(S): %s\n\n', groupnames_string);
    
    % SELECT DATA FOR THIS CONTRAST/CONDITION
    % REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
    
    fprintf('\n\n');
    printhdr('Scaling data if requested in options');
    fprintf('\n\n');
    
    switch mygroupnamefield
        
        case 'contrasts'
            
            switch myscaling_glm

                case 'raw'
                    fprintf('\nContrast calculated on raw (unscaled) condition images used in second-level GLM\n\n');
                    scaling_string = 'no_scaling';
                    cat_obj = DATA_OBJ_CON{c};
                    if imgs_nan
                        cat_obj = cat_obj.get_wh_image(imgs_nan);
                    end

                case 'scaled'
                    fprintf('\nContrast calculated on z-scored condition images used in second-level GLM\n\n');
                    scaling_string = 'scaling_z_score_conditions';
                    cat_obj = DATA_OBJ_CONsc{c};
                    if imgs_nan
                        cat_obj = cat_obj.get_wh_image(imgs_nan);
                    end

                case 'scaled_contrasts'
                    fprintf('\nl2norm scaled contrast images used in second-level GLM\n\n');
                    scaling_string = 'scaling_l2norm_contrasts';
                    cat_obj = DATA_OBJ_CONscc{c};
                    if imgs_nan
                        cat_obj = cat_obj.get_wh_image(imgs_nan);
                    end

                otherwise
                    error('\nInvalid option "%s" defined in myscaling_glm variable in a2_set_default_options script, choose between "raw", "scaled", or "scaled_constrast" given option "%s" defined in mygroupnamefield variable\n\n', myscaling_glm, mygroupnamefield);

            end
            
        case 'conditions'
            
            switch myscaling_glm

                case 'raw'
                    fprintf('\nRaw (unscaled) condition images used in second-level GLM\n\n');
                    scaling_string = 'no_scaling';
                    cat_obj = DATA_OBJ{c};
                    if imgs_nan
                        cat_obj = cat_obj.get_wh_image(imgs_nan);
                    end

                case 'scaled'
                    fprintf('\nZ-scored condition images used in second-level GLM\n\n');
                    scaling_string = 'scaling_z_score_conditions';
                    cat_obj = DATA_OBJsc{c};
                    if imgs_nan
                        cat_obj = cat_obj.get_wh_image(imgs_nan);
                    end

                case 'scaled_contrasts'
                    error('\nInvalid combination of option "%s" defined in myscaling_glm_variable in a2_set_default_options script and option "%s" defined in mygroupnamefield variable, choose between "raw" and "scaled" options\n\n',myscaling_glm,mygroupnamefield);

                otherwise
                    error('\nInvalid option "%s" defined in myscaling_glm variable in a2_set_default_options script, choose between "raw",  and "scaled", given option "%s" defined in mygroupnamefield variable\n\n', myscaling_glm, mygroupnamefield);

            end
            
    end % switch mygroupnamefield - contrasts or conditions
    
  
    % FORMAT AND ATTACH DESIGN MATRIX
    % REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
    
    fprintf('\n\n');
    printhdr('Checking design matrix');
    fprintf('\n\n');
    
    if ~strcmpi(design_matrix_type,'onesample')
        
        % Confirm design_matrix is 1, -1, or mean-centered
        meancentered = ~(abs(mean(X)) > 1000 * eps);
        effectscoded = all(X == 1 | X == -1 | X == 0, 1);
        isconstant = all(X == mean(X, 1), 1);
        vifs = getvif(X);

        if any(isconstant)
            
            fprintf('\n');
            warning('An intercept appears to be added manually. Do not include an intercept - it will be added automatically.');
            warning('Skipping this contrast.');
            fprintf('\n');
            
            continue
        end

        % Report
        design_table = table;
        design_table.Mean = mean(X)';
        design_table.Var = var(X)';
        design_table.EffectsCode = effectscoded';
        design_table.VIF = vifs';
        design_table.Properties.RowNames = groupnames';
        disp(design_table)
        disp(' ');

        if any(~meancentered & ~effectscoded)
            fprintf('\n');
            warning('Some columns are not mean-centered or effects coded. Intercept may not be interpretable');
            fprintf('\nColumns: ')
            fprintf('%d \n', find(~meancentered & ~effectscoded));
        else
            fprintf('\nChecked OK: All columns mean-centered or are effects-coded [1 -1 0]\n\n');
        end

        if any(vifs > 2)
            fprintf('\n');
            warning('Some regressors have high variance inflation factors. Parameters might be poorly estimated or uninterpretable.');
            fprintf('\n');
        else
            fprintf('\nChecked OK: VIFs for all columns are < 2\n\n');
        end
    
    else
        design_table = table;
        design_table.Mean = mean(X)';
        design_table.Var = var(X)';
        
    end % if loop design_matrix_type
    
    cat_obj.X = X;
    
    % SANITY CHECK ON REGRESSORS, SKIP CONTRAST IF NEEDED
    % REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
    
    if ~strcmpi(design_matrix_type,'onesample')
    
        if all(cat_obj.X > 0) || all(cat_obj.X < 0)
            % Only positive or negative weights - nothing to compare

            fprintf('\n');
            warning('Only positive or negative regressor values - bad design, please check');
            fprintf('\n');
            
            continue
        end
        
    end

    % RUN GLM MODEL
    % REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
    
    % VOXEL-WISE
    
    if ~dorobfit_parcelwise
        
        if dorobust
            robuststring = 'robust';
            regresstime = tic;
        else
            robuststring = 'norobust';
        end
        
        fprintf('\n\n');
        printhdr(['Running voxel-wise ', robuststring ' regression']);
        fprintf('\n\n');

        if ~strcmpi(design_matrix_type,'onesample')
            % out.t has t maps for all regressors, intercept is last
            switch mygroupnamefield
                case 'contrasts'
                    regression_stats = regress(cat_obj, .05, 'unc', robuststring, 'analysis_name', DAT.contrastnames{c}, 'variable_names', groupnames, 'nodisplay');
                case 'conditions'
                    regression_stats = regress(cat_obj, .05, 'unc', robuststring, 'analysis_name', DAT.conditions{c}, 'variable_names', groupnames, 'nodisplay');
            end
        else
            % out.t has t maps for intercept only
            switch mygroupnamefield
                case 'contrasts'
                    regression_stats = regress(cat_obj, .05, 'unc', robuststring, 'analysis_name', DAT.contrastnames{c}, 'variable_names', groupnames, 'nointercept', 'nodisplay');
                case 'conditions'
                    regression_stats = regress(cat_obj, .05, 'unc', robuststring, 'analysis_name', DAT.conditions{c}, 'variable_names', groupnames, 'nointercept', 'nodisplay');
            end
        end

        % Make sure variable types are right data formats
        regression_stats.design_table = design_table;
        regression_stats.t = enforce_variable_types(regression_stats.t);
        regression_stats.b = enforce_variable_types(regression_stats.b);
        regression_stats.df = enforce_variable_types(regression_stats.df);
        regression_stats.sigma = enforce_variable_types(regression_stats.sigma);

        % add analysis name, regressor names and other meta-data
        switch mygroupnamefield
            case 'contrasts'
                regression_stats.contrastname = DAT.contrastnames{c};
                regression_stats.contrast = DAT.contrasts(c, :);
                regression_stats.analysis_name = DAT.contrastnames{c};
            case 'conditions'
                regression_stats.contrastname = DAT.conditions{c};
                regression_stats.contrast = 1;
                regression_stats.analysis_name = DAT.conditions{c};
        end

        % add names for variables 
        if ~strcmpi(design_matrix_type,'onesample')
            regression_stats.variable_names = [groupnames {'intercept'}];
        else
            regression_stats.variable_names = groupnames;
        end

        % PLOT ORTHVIEWS (MASKED IF SPECIFIED IN MASKNAME_GLM OPTION)
        % REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
        
        fprintf ('\nORTHVIEWS GLM RESULTS AT UNCORRECTED p < 0.05, EFFECT: %s, REGRESSOR(S): %s, %s, SCALING: %s\n\n', regression_stats.analysis_name, groupnames_string, mask_string, scaling_string);
        
        t = regression_stats.t;
            if maskname_short
                t = apply_mask(t,glmmask);
            end
        orthviews(t);
            for kk = 1:length(regression_stats.variable_names)
                switch mygroupnamefield
                    case 'contrasts'
                        spm_orthviews_name_axis([regression_stats.variable_names{kk},' ',DAT.contrastnames{c}], kk);
                    case 'conditions'
                        spm_orthviews_name_axis([regression_stats.variable_names{kk},' ',DAT.conditions{c}], kk);
                end
            end
        drawnow;snapnow;

        % KEEP RESULTS OBJECTS IN CELL ARRAY FOR SAVING
        % REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-

        regression_stats_results{c} = regression_stats;
        
        if exist(maskname_glm,'file')
            regression_stats_results{c}.maskname = maskname_glm;
        end
        
        if dorobust
            fprintf('\nCumulative run time:\n'), toc(regresstime); 
        end
        
    % PARCEL-WISE    
        
    else
        
        fprintf('\n\n');
        printhdr('Running parcel-wise robust regression');
        fprintf('\n\n');
        
        if csf_wm_covs && remove_outliers
            parcelwise_stats = robfit_parcelwise(cat_obj,'names', groupnames,'csf_wm_covs',true,'remove_outliers',true,'doplot',false);
        elseif csf_wm_covs && ~remove_outliers
            parcelwise_stats = robfit_parcelwise(cat_obj,'names', groupnames,'csf_wm_covs',true,'remove_outliers',false,'doplot',false);
        elseif ~csf_wm_covs && remove_outliers
            parcelwise_stats = robfit_parcelwise(cat_obj,'names', groupnames,'csf_wm_covs',false,'remove_outliers',true,'doplot',false);
        else
            parcelwise_stats = robfit_parcelwise(cat_obj,'names', groupnames,'doplot',false);
        end
            

        % add design table
        parcelwise_stats.design_table = design_table;

        % add analysis name, regressor names, and other meta-data
        switch mygroupnamefield
            case 'contrasts'
                parcelwise_stats.contrastname = DAT.contrastnames{c};
                parcelwise_stats.contrast = DAT.contrasts(c, :);
                parcelwise_stats.analysis_name = DAT.contrastnames{c};
            case 'conditions'
                parcelwise_stats.contrastname = DAT.conditions{c};
                parcelwise_stats.contrast = 1;
                parcelwise_stats.analysis_name = DAT.conditions{c};
        end

        % add names for variables 
        if ~strcmpi(design_matrix_type,'onesample')
            parcelwise_stats.variable_names = [groupnames {'Intercept'}];
        else
            parcelwise_stats.variable_names = groupnames;
        end
        
        % PLOT PARCELWISE SPECIFIC WEIGHTS AND DIAGNOSTICS
        % REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
        fprintf('\nPlotting parcel weights and diagnostics\n\n');
        
        create_figure('parcelwise weights and metrics', 2, 2);
        set(gcf, 'WindowState','maximized');
        xlabel('Image'); ylabel('Weights');
        errorbar(mean(parcelwise_stats.weights), std(parcelwise_stats.weights), 'bo', 'MarkerFaceColor', [0 0 .5])
        title('Mean weights across parcels (s.d. error bars) per image');
        axis tight; 

        subplot(2, 2, 2);
        imagesc(parcelwise_stats.weights);
        xlabel('Image'); ylabel('Parcel');
        title('Weights by parcel');
        colorbar;
        axis tight; set(gca, 'YDir', 'Reverse');

        subplot(2, 2, 3);
        xlabel('Image'); ylabel('Z(Weights)');
        errorbar(zscore(mean(parcelwise_stats.weights)), ste(parcelwise_stats.weights), 'bo-', 'MarkerFaceColor', [0 0 .5], 'LineWidth', 2)
        title('Mean weights (s.e. error bars) and quality metrics');
        plot(zscore(parcelwise_stats.individual_metrics.gm_L1norm), 'LineWidth', 2);
        plot(zscore(parcelwise_stats.individual_metrics.csf_L1norm), 'LineWidth', 2);
        plot(zscore(parcelwise_stats.ind_quality_dat.Mahal_corr), 'LineWidth', 2);
        plot(zscore(parcelwise_stats.ind_quality_dat.Mahal_cov), 'LineWidth', 2);
        legend({'Z(Weights)' 'Z(GM L1 norm)' 'Z(CSF L1 norm)' 'Mahal corr dist' 'Mahal cov dist'});
        axis tight; 

        % mark off who are outliers
        wh_out = find(parcelwise_stats.outliers_uncorr);
        for i = 1:length(wh_out)

            hh = plot_vertical_line(wh_out(i));
            set(hh, 'Color', 'r', 'LineStyle', 'REPLACE_WITH_DASH_DASH');

            if i == 1
                    legend({'Z(Weights)' 'Z(GM L1 norm)' 'Z(CSF L1 norm)' 'Mahal corr dist' 'Mahal cov dist' 'Mah. outliers p<.05 uncor'});
            end
        end

        subplot(2, 2, 4)
        plot_correlation_matrix(parcelwise_stats.datmatrix, 'dofigure', false);
        title('inter-parcel correlations across images');
        drawnow, snapnow;
        

        % PLOT MONTAGE (MASKED IF SPECIFIED IN MASKNAME_GLM OPTION)
        % REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
        
        fprintf ('\nMONTAGE PARCELWISE GLM RESULTS AT UNCORRECTED p < 0.05, EFFECT: %s, REGRESSOR(S): %s, %s, SCALING: %s\n\n', parcelwise_stats.analysis_name, groupnames_string, mask_string, scaling_string);
        
        num_effects = size(parcelwise_stats.t_obj.dat, 2); % number of regressors
        o2 = canlab_results_fmridisplay([], 'multirow', num_effects, 'outline', 'linewidth', 0.5, 'splitcolor',{[.1 .8 .8] [.1 .1 .8] [.9 .4 0] [1 1 0]}, 'overlay', 'mni_icbm152_t1_tal_nlin_sym_09a_brainonly.img');

        for j = 1:num_effects

            tj = get_wh_image(parcelwise_stats.t_obj, j);
                if maskname_short
                    tj = apply_mask(tj, glmmask);
                end
            tj = threshold(tj, .05, 'unc'); 

            o2 = addblobs(o2, region(tj), 'wh_montages', (2*j)-1:2*j);
            o2 = title_montage(o2, 2*j, [parcelwise_stats.analysis_name ' ' parcelwise_stats.variable_names{j} ' ' mask_string ' ' scaling_string]);

        end

        figtitle = sprintf('%s_05_unc_montage_%s_%s_%s', parcelwise_stats.analysis_name, groupnames_string, mask_string, scaling_string);
        set(gcf, 'Tag', figtitle, 'WindowState','maximized');
        drawnow, snapnow;
            if save_figures_glm % corrected save_figures into save_figures_glm
                plugin_save_figure;
            end
        clear o2, clear figtitle, clear j, clear tj

        % KEEP RESULTS OBJECTS IN CELL ARRAY FOR SAVING
        % REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-

        parcelwise_stats_results{c} = parcelwise_stats;
        
        if exist(maskname_glm,'file')
            parcelwise_stats_results{c}.maskname = maskname_glm;
        end
        
    end % if loop voxel- versus parcelwise
    
end  % for loop over contrasts or conditions


%% SAVE RESULTS
% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-

fprintf('\n\n');
printhdr('SAVING GLM RESULTS');
fprintf('\n\n');

if ~dorobfit_parcelwise
        savefilenamedata = fullfile(resultsdir, ['regression_stats_and_maps_', mygroupnamefield, '_', scaling_string, '_', results_suffix, '.mat']);
        save(savefilenamedata, 'regression_stats_results', '-v7.3');
        fprintf('\nSaved regression_stats_results for %s\n', mygroupnamefield);

else
        savefilenamedata = fullfile(resultsdir, ['parcelwise_stats_and_maps_', mygroupnamefield, '_', scaling_string, '_', results_suffix, '.mat']);
        save(savefilenamedata, 'parcelwise_stats_results', '-v7.3');
        fprintf('\nSaved parcelwise_stats_results for %s\n', mygroupnamefield);
end

fprintf('\nFilename: %s\n', savefilenamedata);


##### SOURCE END #####
--></body></html>
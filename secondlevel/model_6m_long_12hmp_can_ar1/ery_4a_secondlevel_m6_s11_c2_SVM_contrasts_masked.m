%%% c2_SVM_contrasts_masked.m

% USAGE
%
% This script displays secondâ»level (i.e. across subjects) support vector
% machine (SVM) results generated by prep_3c_run_SVMs_on_contrasts_masked.m
%
% Use Matlab's publish function to generate html report
% 
% See the documentation of prep_3c_run_SVMs_on_contrasts_masked.m
% for more info and options
%
%__________________________________________________________________________
%
% revamped by: Lukas Van Oudenhove
% date:   KU Leuven, July, 2022
%
%__________________________________________________________________________
% @(#)% c2_SVM_contrasts_masked.m         v2.1
% last modified: 2022/07/30


%% SET OPTIONS & LOAD SVM RESULTS IF NEEDED
%--------------------------------------------------------------------------

% option (from corresponding prep_3c script)

results_suffix = '';

% specify which montage to add title to

whmontage = 5; % see region.montage docs

% check scaling

scaling_string = 'no_scaling';
    
    if exist('dosubjectnorm', 'var') && dosubjectnorm
        scaling_string = 'scaling_l2norm_subjects';
        fprintf('\nCondition images for each subject were normalized by L2 norm of Condition 1 image before SVM\n');
        
    elseif exist('doimagenorm','var') && doimagenorm  
        scaling_string = 'scaling_l2norm_conditions';
        fprintf('\nEach condition image for each subject was normalized by L2 norm before SVM\n');
        
    elseif exist('dozscoreimages', 'var') && dozscoreimages
        fprintf('\nEach condition image for each subject was z-scored before SVM\n');
        scaling_string = 'scaling_z_score_conditions';
        
    end
    
% check whether results are available, load if needed

resultsvarname = 'svm_stats_results';
resultsstring = 'svm_stats_results_contrasts_';

if ~exist(resultsvarname,'var')
    savefilenamedata = fullfile(resultsdir, [resultsstring, scaling_string, '_', results_suffix, '.mat']);
        if exist(savefilenamedata, 'file')
            fprintf('\nLoading SVM results from %s\n\n', savefilenamedata);
            load(savefilenamedata, resultsvarname);
        else
            fprintf('\nNo saved SVM results file %s. Skipping this analysis.', savefilenamedata)
            fprintf('\nRun prep_3c_run_SVMs_on_contrasts_masked.m to get svm results first.\n'); 
            return
        end
else
    fprintf('\n%s found, displaying results\n\n', resultsvarname);
end


%% MASKING
%--------------------------------------------------------------------------

if exist(maskname_svm, 'file')
    [~,maskname_short] = fileparts(maskname_svm);
    mask_string = sprintf('within_%s', maskname_short);
else
    mask_string = sprintf('without_masking');
end  


%% AVERAGE IMAGES FROM THE SAME PERSON WITHIN EACH SVM CLASS IF NEEDED
% -------------------------------------------------------------------------

% - This plugin function calculates (a) cross-validated distances from the
% SVM hyerplane, and (b) a cross-classification matrix across contrasts
% - It averages images within the same subject and condition (+ or -,
% on/off in the SVM analysis) into one image for testing purposes, so that
% it performs a subject-wise forced choice classification
% - It assumes that the image lists for each condition contain images for subjects 1:n
% in each condition, in the same order.

% The purpose of this plugin is to average over replicates of images with the
% same outcome collected on the same individuals.  We want one average
% image for outcome 1 and one average image for outcome -1 per person, and
% we want to test person-wise classification.
%
% Depending on how contrasts are specified, stats results structure from SVM training
% may involve multiple images coded
% with 1 or -1 per person, in which case the svm_stats_results stats
% structures will contain image-wise classification results, not
% person-wise averaging over images for each person.
% This function calculates an average pattern expression value (distance from hyperplane)
% for each person for images coded as 1 and those coded as -1.
%
% For example, if you are testing a [1 1 1 1 -1 -1 -1 -1] contrast, you
% will end up with 8 images per person in the SVM analysis, 4 for each
% condition. You want to test the average of the first 4 vs. the average of
% the last 4 when you caculate test accuracy.

[dist_from_hyperplane, Y, svm_dist_pos_neg, svm_dist_pos_neg_matrix] = plugin_svm_contrasts_get_results_per_subject(DAT, svm_stats_results, DATA_OBJ);


%% CHECK WHETHER WE HAVE PAIRED IMAGES AND ERROR OUT IF NOT
% -------------------------------------------------------------------------

kc = size(DAT.contrasts, 1);

ispaired = false(1, kc);

for i = 1:kc
    ispaired(i) = sum(Y{i} > 0) == sum(Y{i} < 0);
end

if ~all(ispaired)
    error('This script should only be run on paired, within-person contrasts. Check images and results. Skipping this analysis.');
end


%% DEFINE EFFECT SIZE FUNCTIONS AND ROC TYPE
% -------------------------------------------------------------------------

% Define paired and uppaired functions here for reference
% This script uses the paired option because it runs within-person
% contrasts

% ROC plot is different for paired samples and unpaired. Paired samples
% must be in specific order, 1:n for condition 1 and 1:n for condition 2.
% If samples are paired, this is set up by default in these scripts.
% But some contrasts entered by the user may be unbalanced, i.e., different
% numbers of images in each condition, unpaired. Other SVM scripts are set up
% to handle this condition explicitly and run the unpaired version.  

% Effect size, cross-validated, paired samples
dfun_paired = @(x, Y) mean(x(Y > 0) - x(Y < 0)) ./ std(x(Y > 0) - x(Y < 0));

% Effect size, cross-validated, unpaired sampled
dfun_unpaired = @(x, Y) (mean(x(Y > 0)) - mean(x(Y < 0))) ./ sqrt(var(x(Y > 0)) + var(x(Y < 0))); % check this. @lukasvo76 appears unused here hence we may not need it, but does not harm

rocpairstring = 'twochoice';  % 'twochoice' or 'unpaired'


%% CROSS-VALIDATED ACCURACY AND ROC PLOTS FOR EACH CONTRAST
% -------------------------------------------------------------------------

printhdr('Cross-validated SVM to discriminate within-person contrasts');

for c = 1:kc
    
    analysisname = DAT.contrastnames{c};
    printhdr(analysisname);
    
    if isempty(dist_from_hyperplane{c})
        
        warning('\nContrast %s not suitable for SVM. Skipping this contrast and continuing.\n', DAT.contrastnames{c});

        continue
        
    end
    
    % ROC PLOT
    % --------------------------------------------------------------------
    
    figtitle = sprintf('SVM ROC %s', analysisname);
    create_figure(figtitle);
    set(gcf,'WindowState','maximized');
    
    ROC = roc_plot(dist_from_hyperplane{c}, logical(Y{c} > 0), 'color', DAT.contrastcolors{c}, rocpairstring);
    
    d_paired = dfun_paired(dist_from_hyperplane{c}, Y{c});
    fprintf('Effect size, cross-validated: Forced choice: d = %3.2f\n\n', d_paired);
    
    drawnow, snapnow;
    
    if save_figures_svm
        plugin_save_figure
    end
    
%     close(gcf);

    % PLOT THE SVM MAPS
    % --------------------------------------------------------------------
    
    % Get the stats results for this contrast, with weight map
    stats = svm_stats_results{c};
    
    % FDR-corrected
        
        % montage

        fprintf ('\nShowing SVM results at FDR q < %1.4f: %s, %s\n\n', q_threshold_svm, analysisname, mask_string);

        t = stats.weight_obj;
        t = threshold(t, q_threshold_svm, 'fdr', 'k', k_threshold_svm); 
        r = region(t,'noverbose');

        o2 = montage(r, 'colormap', 'splitcolor',{[.1 .8 .8] [.1 .1 .8] [.9 .4 0] [1 1 0]});
        o2 = title_montage(o2, whmontage, [analysisname ' FDR ' num2str(q_threshold) ' ' mask_string]);

        figtitle = sprintf('%s_%s_%1.4f_FDR_montage_%s_%s', analysisname, results_suffix, q_threshold_svm, scaling_string, mask_string);
        set(gcf, 'Tag', figtitle, 'WindowState','maximized');
        drawnow, snapnow;
            if save_figures_svm
                plugin_save_figure;
            end
            
        clear o2, clear figtitle
        
        % table and montage of regioncenters
        
        fprintf('\n\nTable of results for clusters %d contiguous voxels.\n', k_threshold_svm);

        r(cat(1, r.numVox) < k_threshold_svm) = [];
        [rpos, rneg] = table(r);       % add labels
        r = [rpos rneg];               % re-concatenate labeled regions

        if ~isempty(r)
            
            o3 = montage(r, 'colormap', 'regioncenters', 'splitcolor',{[.1 .8 .8] [.1 .1 .8] [.9 .4 0] [1 1 0]});

            % Activate, name, and save figure
            figtitle = sprintf('%s_%s_%1.4f_FDR_regions_%s_%s', analysisname, results_suffix, q_threshold_svm, scaling_string, mask_string);
            set(gcf, 'Tag', figtitle, 'WindowState','maximized');
            drawnow, snapnow;
                if save_figures_svm
                    plugin_save_figure;
                end
                
            clear o3, clear figtitle, clear t, clear r

        end % conditional montage plot if there are regions to show
    
    % uncorrected
        
        % montage

        fprintf ('\nShowing SVM results at uncorrected p < %1.4f: %s, %s\n\n', p_threshold_svm, analysisname, mask_string);

        t = stats.weight_obj;
        t = threshold(t, p_threshold_svm, 'unc', 'k', k_threshold_svm); 
        r = region(t,'noverbose');

        o2 = montage(r, 'colormap', 'splitcolor',{[.1 .8 .8] [.1 .1 .8] [.9 .4 0] [1 1 0]});
        o2 = title_montage(o2, whmontage, [analysisname ' unc ' num2str(p_threshold) ' ' mask_string]);

        figtitle = sprintf('%s_%s_%1.4f_unc_montage_%s_%s', analysisname, results_suffix, p_threshold_svm, scaling_string, mask_string);
        set(gcf, 'Tag', figtitle, 'WindowState','maximized');
        drawnow, snapnow;
            if save_figures_svm
                plugin_save_figure;
            end
            
        clear o2, clear figtitle
        
        % table and montage of regioncenters
        
        fprintf('\n\nTable of results for clusters %d contiguous voxels.\n', k_threshold_svm);

        r(cat(1, r.numVox) < k_threshold_svm) = [];
        [rpos, rneg] = table(r);       % add labels
        r = [rpos rneg];               % re-concatenate labeled regions

        if ~isempty(r)
            
            o3 = montage(r, 'colormap', 'regioncenters', 'splitcolor',{[.1 .8 .8] [.1 .1 .8] [.9 .4 0] [1 1 0]});

            % Activate, name, and save figure
            figtitle = sprintf('%s_%s_%1.4f_unc_regions_%s_%s', analysisname, results_suffix, p_threshold_svm, scaling_string, mask_string);
            set(gcf, 'Tag', figtitle, 'WindowState','maximized');
            drawnow, snapnow;
                if save_figures_svm
                    plugin_save_figure;
                end
                
            clear o3, clear figtitle, clear t, clear r
            
        end % conditional montage plot if there are regions to show
    
end  % loop over contrasts


%% CROSS-CLASSIFICATION MATRIX
%--------------------------------------------------------------------------
% uses svm_dist_pos_neg_matrix from plugin

% Get rid of empties (invalid contrasts)
isemptymtx = cellfun(@isempty, svm_dist_pos_neg_matrix);
wh_ok = ~all(isemptymtx);

%svm_dist_pos_neg_matrix(wh_ok, wh_ok)

diff_function = @(x) x(:, 1) - x(:, 2);         % should be positive for correct classification

iscorrect = @(x) sign(diff_function(x)) > 0;

cohens_d_function = @(x) mean(x) ./ std(x);

acc_function = @(corr_idx) 100 * sum(corr_idx) ./ length(corr_idx);

svm_dist_per_subject_and_condition = cellfun(diff_function, svm_dist_pos_neg_matrix(wh_ok, wh_ok), 'UniformOutput', false);

svm_cohens_d_train_transfer = cell2mat(cellfun(cohens_d_function, svm_dist_per_subject_and_condition, 'UniformOutput', false));

accuracy_by_subject_and_condition = cellfun(iscorrect, svm_dist_pos_neg_matrix(wh_ok, wh_ok), 'UniformOutput', false);

accuracy = cellfun(acc_function, accuracy_by_subject_and_condition, 'UniformOutput', false);
accuracy = cell2mat(accuracy);


%% FIGURE CROSS-VALIDATED DISTANCE FROM HYPERPLANE
% -------------------------------------------------------------------------
figtitle = sprintf('SVM Cross_classification');
create_figure(figtitle);
set(gcf,'WindowState','maximized');

% pos = get(gcf, 'Position');
% pos(3) = pos(3) * 1.7;
% set(gcf, 'Position', pos)

printhdr('Cross-validated distance from hyperplane. > 0 is correct classification');

[ntrain, ntransfer] = size(svm_dist_per_subject_and_condition);
text_xval = [];
han = {};

trainnames = DAT.contrastnames(wh_ok);

for c = 1:ntrain  % for non-empty contrasts only
   
    dat = svm_dist_per_subject_and_condition(c, :);
    
    xvals = 1 + ntransfer * (c-1) : c * ntransfer;
    
    xvals = xvals + c - 1; % skip a space

    text_xval(c) = mean(xvals);
    mycolors = DAT.contrastcolors(wh_ok);
    
    trainname = trainnames{c};
    xtick_text{c} = sprintf('Train %s', trainname);
    
    printhdr(sprintf('Train on %s', trainname));
    
    han{c} = barplot_columns(dat, 'nofig', 'noviolin', 'colors', mycolors, 'x', xvals, 'names', trainnames);
    set(gca, 'XLim', [.5 xvals(end) + .5]);
    
end

xlabel(' ');
ylabel('Distance from hyperplane');

barhandles = cat(2, han{1}.bar_han{:});
legend(barhandles, trainnames)

set(gca, 'XTick', text_xval, 'XTickLabel', xtick_text, 'XTickLabelRotation', 45);

printhdr('Accuracy matrix - training (rows) by test contrasts (columns)');
print_matrix(accuracy, trainnames, trainnames);

if save_figures_svm
    plugin_save_figure;
end


%% FIGURE AND STATS ON EFFECT SIZES
% -------------------------------------------------------------------------
figtitle = sprintf('SVM Cross-classification effect sizes');
create_figure(figtitle);
set(gcf,'WindowState','maximized');

% pos = get(gcf, 'Position');
% pos(3) = pos(3) * 1.7;
% set(gcf, 'Position', pos)

printhdr(figtitle);

imagesc(svm_cohens_d_train_transfer, [0 max(svm_cohens_d_train_transfer(:))])
set(gca, 'YDir', 'reverse', 'YTick', 1:ntrain,  'YTickLabel', xtick_text(1:ntrain), 'XTick', 1:ntrain, 'XTickLabel', trainnames, 'XTickLabelRotation', 45);
title(figtitle);
xlabel('Test condition');
ylabel('Training condition');
colorbar
cm = colormap_tor([1 1 1], [1 0 0]);
colormap(cm)

if save_figures_svm
    plugin_save_figure;
end

disp('Cohen''s d for training and transfer');
print_matrix(svm_cohens_d_train_transfer, trainnames, xtick_text(1:ntrain));

